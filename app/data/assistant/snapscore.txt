Projet : SnapScore+ — Orchestration multi-compte locale

SnapScore+ est un orchestrateur multi-comptes local, basé sur Node.js et Puppeteer. Il pilote plusieurs profils Chrome pour envoyer et ouvrir des snaps en boucle via des macros dédiées. L’objectif : maximiser le Snap Score d’un compte en automatisant l’interface comme le ferait un humain, sur une seule machine.

Contexte : Snapchat et Snap Score

Snapchat est un réseau social centré sur l’envoi de photos et vidéos éphémères. Le Snap Score augmente en reproduisant deux actions simples :

Ouvrir un snap reçu : +1

Quelqu’un ouvre un snap que vous avez envoyé : +1

En usage normal, la plupart des comptes restent à quelques centaines ou milliers de points. Dépasser plusieurs millions devient rare sans automatisation ou usage massif.

Origine du projet :

Je voulais mesurer jusqu’où un Snap Score pouvait monter en automatisant l’interface de manière réaliste, sur une seule machine, sans infrastructure distante.

Les étapes :

Prototype mobile

Deux téléphones et quelques macros simples permettent d’atteindre ~30 points/minute.

Cela valide l’idée, mais montre vite que multiplier les appareils n’est pas viable à long terme.

Userscript web (Tampermonkey)

Un script Tampermonkey qui clique dans l’interface web montre que c’est faisable, double le débit (~60 points/minute), mais nécessite que le PC soit focalisé sur les fenêtres visibles.

Très dépendant de l’interface, fragile aux changements.

Orchestrateur Node.js / Puppeteer

Pilotage de plusieurs fenêtres (double session principale + comptes assistants) avec gestion de verrous, pauses courtes et règles de redémarrage.

Permet de garder le bureau utilisable tout en atteignant environ 460 points/minute sur neuf fenêtres.

L’orchestrateur est ce qui change tout : il coordonne les fenêtres, évite les collisions et se récupère automatiquement en cas de dérive.

Architecture technique :

Objectif général : maximiser le score du compte principal en coordonnant des comptes assistants, en local, tout en gardant un débit stable sans serveurs distants.

Composants clés :

Orchestrateur local (Node.js + Puppeteer) qui ouvre, pilote et supervise chaque fenêtre Chrome.

Compte principal réparti sur deux fenêtres parallèles pour maximiser les envois “utiles”.

Comptes assistants dédiés à l’ouverture des snaps et à l’alimentation du backlog.

Planificateur qui attribue les rôles, cadence envois et lectures, surveille l’état des sessions.

Règles de gestion des ressources :

Verrou caméra : un seul envoi à la fois sur le compte principal.

Backlog contrôlé : pause automatique au-delà de 25 snaps non lus pour éviter l’engorgement.

Redémarrages seuils : une fenêtre est redémarrée quand la latence envoi/lecture dépasse ~1s (après reset, lectures ~500 ms, envois ~700 ms).

Garde-fous : chaque action attend que l’élément cible existe et soit visible plutôt que d’utiliser des temporisations arbitraires.

Observabilité et contrôles :

Compteurs par fenêtre : envois/lectures réussis, taille de file, latences p50/p95.

Boucle de supervision (startCheckingIssues) : agrège les moyennes, calcule les points/min et déclenche des redémarrages ciblés (principal, assistants ou global).

Logs structurés (startLog) avec durée de session, moyennes envoi/lecture, backlog, état “sain” ou “bloqué”.

Ralentissements gérés automatiquement via ralentissement ou redémarrage.

Stack technique :

JavaScript

Node.js

Puppeteer

Prototype initial en userscript Tampermonkey

Modules :

Prototype mobile

Objectif : valider l’idée en synchronisant un téléphone qui envoie et un autre qui ouvre les snaps.

Techno : MacroDroid.

Avantages : mise en place rapide, proche d’un usage normal.

Limites : plusieurs téléphones branchés en continu, macros fragiles, caméra monopolisée, configuration pénible.

Performance : ~25 points/minute.

Userscript web

Objectif : accélérer en automatisant via le navigateur tout en gardant un retour visuel.

Techno : JavaScript, Tampermonkey.

Avantages : réglages clairs, tests rapides, facilité d’itération.

Limites :

PC monopolisé sans second écran.

Casse au moindre changement d’interface Snapchat.

Défenses côté plateforme : rythme bridé, sessions qui sautent.

Caméra et micro monopolisés par le navigateur.

Ralentissements sur longues sessions.

Performance : ~60 points/minute.

Orchestrateur Puppeteer

Objectif : exploiter au maximum une machine locale en pilotant plusieurs comptes en parallèle avec des règles simples et un suivi continu.

Techno : Node.js, JavaScript, Puppeteer.

Avantages :

Chaque compte a sa session isolée avec reconnexion automatique.

Fenêtres visibles ou discrètes, lancement planifié.

Gestion fine des ressources : caméra, redémarrages, évitement des bouchons.

Suivi centralisé avec indicateurs mis à jour en continu.

Potentiellement déployable facilement sur d’autres machines.

Limites :

Performances dépendantes du matériel (CPU, RAM, disque, encodage).

La mémoire augmente avec le nombre d’instances.

Performance : ~430–460 points/minute avec 2 comptes principaux et 7 assistants.

Fonctionnement détaillé :

Un AccountManager supervise les comptes : connexion, vérification d’état, attribution des rôles.

Chaque compte possède son profil navigateur avec cookies sauvegardés pour se reconnecter automatiquement.

Les comptes principaux envoient les snaps, les assistants les ouvrent.

Chaque compte observe sa propre conversation pour agir au bon moment, sans temporisateur fixe.

Des compteurs agrégés suivent en temps réel envois, lectures, moyennes et taille de backlog.

Les métriques sont rafraîchies toutes les 500 ms dans la console.

Règles clés :

verrou caméra (un seul compte utilise la caméra à la fois),

pause au-delà de 25 snaps non lus,

redémarrage ciblé des fenêtres qui dérivent,

auto-reconnexion en cas de crash ou d’état incohérent.

Structure du code (simplifiée) :

src/DOM/ : sélecteurs et observateurs pour suivre discussions, messages et triggers.

src/macros/ : scripts côté client pour envoyer et ouvrir des snaps.

src/scripts/focus.js : désactive certaines protections de focus/screenshot pour stabiliser Snapchat Web.

src/Snapchat/account.js : définit une session Puppeteer (profil, connexion, injection de scripts).

src/Snapchat/manager.js : coordonne les comptes, agrège les métriques, gère les redémarrages.

src/utils/cameraMutex.js : logique de verrou sur la caméra.

Résultats et constats :

Meilleur compromis autour de 9 fenêtres (2 comptes principaux, 7 assistants).

Débit soutenu : environ 460 points/minute.

Exemple de résultats : ~10 000 000 points sur le compte principal en 14 jours, ~1 000 000 par compte assistant.

Constats :

Un compte peut être connecté à deux endroits en même temps.

Laisser une session ouverte trop longtemps finit par ralentir tout le monde.

La caméra ne peut pas être utilisée en parallèle par plusieurs instances.

Remarque :

Ce projet est expérimental et personnel. Automatiser une interface peut aller à l’encontre des conditions d’utilisation d’une plateforme. Le code se limite à l’automatisation locale de l’interface web publique, dans un cadre de test et d’exploration technique.